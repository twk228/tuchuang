[
    {
        "id": "twk-question1",
        "topic": "Vue的基本原理是什么？",
        "notes": "",
        "renderType": "html",
        "isShowAnswer": false,
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<p style=\"line-height: 2;\"><span style=\"font-family: Pacifico;\">当一个Vue实例创建时，Vue会遍历</span><strong style=\"font-family: Pacifico;\">data</strong><span style=\"font-family: Pacifico;\">中的属性，用 </span><strong style=\"font-family: Pacifico;\">Object.defineProperty</strong><span style=\"font-family: Pacifico;\">（vue3.0使用proxy ）将它们转为 </span><strong style=\"font-family: Pacifico;\">getter/setter</strong><span style=\"font-family: Pacifico;\">，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 </span><strong style=\"font-family: Pacifico;\">watcher </strong><span style=\"font-family: Pacifico;\">程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</span></p>"
    },
    {
        "id": "twk-question2",
        "topic": "Vue的双向数据绑定的原理是什么？",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<p style=\"line-height: 2;\">Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty</strong>()来劫持各个属性的<strong>setter</strong>，<strong>getter</strong>，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li style=\"line-height: 2;\">需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li style=\"line-height: 2;\">compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li style=\"line-height: 2;\">Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li style=\"line-height: 2;\">MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol>"
    },
    {
        "id": "twk-question3",
        "topic": "使用 Object.defineProperty() 来进行数据劫持有什么缺点？",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p><br></p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>"
    },
    {
        "id": "twk-question4",
        "topic": "Computed 和 Watch 的区别是什么？",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<h3>对于Computed：</h3><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><h3><br></h3><h3>对于Watch：</h3><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</li><li class=\"ql-indent-1\">  immediate：组件加载立即触发回调函数</li><li class=\"ql-indent-1\">  deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><p><br></p><h3>总结</h3><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 </li><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 </li></ul><p><br></p><h3>运用场景： </h3><ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 </li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 </li></ul>"
    },
    {
        "id": "twk-question5",
        "topic": "slot是什么？有什么作用？原理是什么？",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p><br></p><p><strong>实现原理：</strong>当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<strong>vm.$slot</strong>中，默认插槽为<strong>vm.$slot.default</strong>，具名插槽为<strong>vm.$slot.xxx</strong>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<strong>$slot</strong>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>"
    },
    {
        "id": "twk-question6",
        "topic": "常见的事件修饰符及其作用",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<ol><li><strong>.stop</strong>：等同于 JavaScript 中的 <strong>event.stopPropagation()</strong> ，防止事件冒泡；</li><li><strong>.prevent </strong>：等同于 JavaScript 中的 <strong>event.preventDefault()</strong> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><strong>.capture </strong>：与事件冒泡的方向相反，事件捕获由外到内；</li><li><strong>.self </strong>：只会触发自己范围内的事件，不包含子元素；</li><li><strong>.once</strong> ：只会触发一次。</li></ol>"
    },
    {
        "id": "twk-question7",
        "topic": "v-if、v-show、v-html 的原理",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li> v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </li><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul>"
    },
    {
        "id": "twk-question8",
        "topic": "v-if和v-show的区别",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul>"
    },
    {
        "id": "twk-question9",
        "topic": "data为什么是一个函数而不是对象？",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。"
    },
    {
        "id": "twk-question10",
        "topic": "$nextTick 原理及作用",
        "isShowAnswer": false,
        "renderType": "html",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "<p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p><br></p><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p><br></p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p><p><br></p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul><p><br></p><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。</p><p><br></p><p>由于Vue的DOM操作是异步的，所以，在以下情况下，会用到nextTick：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。</li></ul><p><br></p><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</p>"
    },
    {
        "id": "twk-question11",
        "topic": "Vue 的生命周期钩子有哪些？它们在什么阶段被调用？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "Vue 的生命周期钩子可以分为8个主要阶段：\n\n1. **创建阶段**\n   - `beforeCreate`：实例刚创建，数据观测和事件配置之前调用\n   - `created`：实例创建完成，数据观测已完成，但DOM还未生成\n\n2. **挂载阶段**\n   - `beforeMount`：模板编译/挂载之前调用\n   - `mounted`：模板编译/挂载完成后调用\n\n3. **更新阶段**\n   - `beforeUpdate`：数据更新时，虚拟DOM重新渲染和打补丁之前调用\n   - `updated`：数据更改导致的虚拟DOM重新渲染和打补丁之后调用\n\n4. **销毁阶段**\n   - `beforeDestroy`：实例销毁之前调用\n   - `destroyed`：实例销毁后调用\n\nVue 3.x 中还新增了：\n- `onRenderTracked` 和 `onRenderTriggered`：用于调试组件的重新渲染"
    },
    {
        "id": "twk-question12",
        "topic": "Vue 2 和 Vue 3 的主要区别是什么？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "Vue 3 相比 Vue 2 的主要改进：\n\n1. **性能提升**\n   - 使用Proxy代替Object.defineProperty实现响应式\n   - 重写虚拟DOM，优化渲染性能\n   - 更好的Tree Shaking支持\n\n2. **Composition API**\n   - 引入setup函数和组合式API\n   - 更好的逻辑复用和组织代码\n\n3. **TypeScript支持**\n   - 使用TypeScript重写，提供更好的TS支持\n\n4. **片段(Fragments)**\n   - 支持多个根节点的组件\n\n5. **Teleport组件**\n   - 可以将组件内容渲染到DOM的任何位置\n\n6. **Suspense组件**\n   - 更好地处理异步组件加载\n\n7. **更小的体积**\n   - 核心库体积更小，打包后文件更小"
    },
    {
        "id": "twk-question13",
        "topic": "Vue 中的 computed 和 watch 有什么区别？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "| 特性 | computed | watch |\n|------|---------|-------|\n| 用途 | 计算属性，基于依赖缓存 | 监听数据变化，执行副作用 |\n| 缓存 | 有缓存，依赖不变不重新计算 | 无缓存，每次变化都会执行 |\n| 返回值 | 必须返回一个值 | 不需要返回值 |\n| 异步 | 不支持异步操作 | 支持异步操作 |\n| 使用场景 | 模板中复杂的逻辑计算 | 数据变化时执行异步或开销较大的操作 |\n\n**computed 适用场景**：\n- 需要根据多个数据计算出一个值\n- 需要在模板中使用的复杂表达式\n- 需要缓存优化性能的计算\n\n**watch 适用场景**：\n- 监听数据变化执行异步操作\n- 监听数据变化执行开销较大的操作\n- 需要在数据变化时执行特定业务逻辑"
    },
    {
        "id": "twk-question14",
        "topic": "Vue 组件间通信的方式有哪些？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "Vue 组件间通信的多种方式：\n\n1. **Props / $emit**\n   - 父组件通过 props 向下传递数据\n   - 子组件通过 $emit 向上发送事件\n\n2. **$parent / $children**\n   - 通过父链/子链直接访问组件实例\n   - 不推荐使用，增加了耦合度\n\n3. **$refs**\n   - 访问子组件实例或 DOM 元素\n\n4. **Event Bus**\n   - 创建一个空的 Vue 实例作为事件中心\n   - 通过 $on, $emit 进行跨组件通信\n\n5. **Vuex**\n   - 状态管理库，用于复杂应用的状态管理\n   - 提供全局状态和可预测的状态变更\n\n6. **provide / inject**\n   - 祖先组件通过 provide 提供数据\n   - 后代组件通过 inject 注入数据\n   - 主要用于高阶插件/组件库\n\n7. **$attrs / $listeners**\n   - $attrs 包含父作用域中不作为 prop 被识别的特性\n   - $listeners 包含父作用域中的 v-on 事件监听器\n\n8. **Vue 3 的 Composition API**\n   - 使用 reactive, ref 等函数创建响应式状态\n   - 通过模块导入的方式共享状态"
    },
    {
        "id": "twk-question15",
        "topic": "什么是 Vuex？它的核心概念是什么？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "Vuex 是 Vue.js 的状态管理模式+库，用于集中管理应用的所有组件的状态。\n\n**Vuex 的核心概念**：\n\n1. **State**：驱动应用的数据源，单一状态树\n   ```javascript\n   state: {\n     count: 0,\n     user: null\n   }\n   ```\n\n2. **Getters**：从 state 中派生的状态，相当于计算属性\n   ```javascript\n   getters: {\n     doubleCount: state => state.count * 2\n   }\n   ```\n\n3. **Mutations**：更改 state 的唯一方法，同步操作\n   ```javascript\n   mutations: {\n     increment(state, payload) {\n       state.count += payload.amount\n     }\n   }\n   ```\n\n4. **Actions**：提交 mutation，可以包含异步操作\n   ```javascript\n   actions: {\n     incrementAsync({ commit }, payload) {\n       setTimeout(() => {\n         commit('increment', payload)\n       }, 1000)\n     }\n   }\n   ```\n\n5. **Modules**：将 store 分割成模块，每个模块拥有自己的 state、getters、mutations、actions\n\n**Vuex 的工作流程**：\n组件 → Dispatch Actions → Commit Mutations → Mutate State → Render Components"
    },
    {
        "id": "twk-question16",
        "topic": "Vue 的路由导航守卫有哪些？它们的作用是什么？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "Vue Router 提供了多种导航守卫，用于控制路由的跳转和访问权限。\n\n**全局守卫**：\n1. `router.beforeEach` - 全局前置守卫\n   - 在路由跳转前调用\n   - 常用于权限验证\n   \n2. `router.beforeResolve` - 全局解析守卫\n   - 在导航被确认之前，组件内守卫和异步路由组件被解析之后调用\n   \n3. `router.afterEach` - 全局后置钩子\n   - 在导航完成后调用\n   - 不会接受 next 函数，也不会改变导航本身\n\n**路由独享守卫**：\n- `beforeEnter` - 在路由配置上直接定义\n  ```javascript\n  const routes = [\n    {\n      path: '/admin',\n      component: Admin,\n      beforeEnter: (to, from, next) => {\n        // 验证权限\n      }\n    }\n  ]\n  ```\n\n**组件内守卫**：\n1. `beforeRouteEnter` - 在渲染该组件的对应路由被确认前调用\n   - 不能访问组件实例 `this`\n   \n2. `beforeRouteUpdate` - 在当前路由改变，但该组件被复用时调用\n   - 可以访问组件实例 `this`\n   \n3. `beforeRouteLeave` - 导航离开该组件的对应路由时调用\n   - 常用于提示用户保存未保存的修改\n\n**守卫参数**：\n- `to`：即将要进入的目标路由对象\n- `from`：当前导航正要离开的路由\n- `next`：函数，必须调用 resolve 这个钩子\n  - `next()`：进行管道中的下一个钩子\n  - `next(false)`：中断当前的导航\n  - `next('/')` 或 `next({ path: '/' })`：跳转到一个不同的地址"
    },
    {
        "id": "twk-question17",
        "topic": "Vue 的响应式原理是什么？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "### Vue 2 的响应式原理\n\nVue 2 使用 **Object.defineProperty** 实现响应式：\n\n1. **数据劫持**：遍历 data 对象的所有属性，使用 Object.defineProperty 设置 getter 和 setter\n2. **依赖收集**：在 getter 中收集依赖（Watcher）\n3. **派发更新**：在 setter 中通知依赖更新，触发重新渲染\n\n**实现过程**：\n```javascript\n// 简化版实现\nfunction defineReactive(obj, key, val) {\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      // 收集依赖\n      if (Dep.target) {\n        dep.depend();\n      }\n      return val;\n    },\n    set: function reactiveSetter(newVal) {\n      if (newVal === val) return;\n      val = newVal;\n      // 通知更新\n      dep.notify();\n    }\n  });\n}\n```\n\n**局限性**：\n- 无法检测对象属性的添加或删除（需使用 Vue.set/Vue.delete）\n- 无法检测数组索引和长度的变化\n- 需要对原始数据对象进行递归遍历\n\n### Vue 3 的响应式原理\n\nVue 3 使用 **Proxy** 实现响应式：\n\n1. **代理对象**：使用 Proxy 代理整个对象\n2. **拦截操作**：拦截各种操作（get、set、deleteProperty等）\n3. **惰性响应**：只在访问属性时创建响应式\n\n**优势**：\n- 可以检测到对象属性的添加和删除\n- 可以检测数组索引和长度的变化\n- 性能更好，不需要递归遍历所有属性\n- 支持 Map、Set、WeakMap、WeakSet 等数据结构\n\n```javascript\n// 简化版实现\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key, receiver) {\n      // 收集依赖\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      // 通知更新\n      trigger(target, key);\n      return Reflect.set(target, key, value, receiver);\n    },\n    deleteProperty(target, key) {\n      // 通知更新\n      trigger(target, key);\n      return Reflect.deleteProperty(target, key);\n    }\n  });\n}\n```"
    },
    {
        "id": "twk-question18",
        "topic": "什么是虚拟 DOM？Vue 中虚拟 DOM 的作用是什么？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "### 什么是虚拟 DOM？\n\n虚拟 DOM（Virtual DOM）是一个轻量级的 JavaScript 对象，它是真实 DOM 的抽象表示。虚拟 DOM 节点（VNode）描述了真实 DOM 节点的标签名、属性、子节点等信息。\n\n### Vue 中虚拟 DOM 的作用\n\n1. **提高性能**：\n   - 减少直接操作真实 DOM 的次数\n   - 通过 diff 算法找出最小变更，批量更新 DOM\n   - 避免不必要的 DOM 操作，提高渲染性能\n\n2. **跨平台能力**：\n   - 虚拟 DOM 是 JavaScript 对象，不依赖具体平台\n   - 可以在浏览器、Native、小程序等不同平台渲染\n\n3. **简化开发**：\n   - 开发者只需关注数据变化，不需要手动操作 DOM\n   - Vue 自动处理视图更新\n\n### Vue 的虚拟 DOM 工作流程\n\n1. **编译阶段**：模板编译为渲染函数\n2. **渲染阶段**：执行渲染函数，生成虚拟 DOM 树\n3. **挂载阶段**：将虚拟 DOM 树转换为真实 DOM\n4. **更新阶段**：数据变化时生成新的虚拟 DOM 树\n5. **对比阶段**：对比新旧虚拟 DOM 树（diff 算法）\n6. **打补丁**：将差异应用到真实 DOM\n\n### Vue 3 的虚拟 DOM 优化\n\nVue 3 对虚拟 DOM 进行了多项优化：\n\n1. **静态提升**：将静态节点提升到渲染函数外部，避免重复创建\n2. **Patch Flags**：为动态节点添加标记，优化 diff 过程\n3. **Tree Flattening**：减少嵌套层级，优化渲染性能\n4. **缓存事件处理函数**：避免不必要的重新渲染\n\n这些优化使得 Vue 3 的虚拟 DOM 比 Vue 2 更加高效。"
    },
    {
        "id": "twk-question19",
        "topic": "Vue 中的 key 属性有什么作用？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "### key 属性的作用\n\nkey 是 Vue 中一个特殊的属性，主要用在 v-for 列表中，它的作用是：\n\n1. **标识节点身份**：帮助 Vue 识别哪些节点是被添加、修改或删除的\n2. **优化渲染性能**：通过 key 可以更高效地更新虚拟 DOM\n3. **维持组件状态**：避免组件状态在列表重新渲染时丢失\n\n### 为什么需要 key\n\n没有 key 时，Vue 会使用一种\"就地复用\"的策略：\n- 默认使用\"就地复用\"策略\n- 如果数据项的顺序被改变，Vue 不会移动 DOM 元素\n- 而是尝试就地修改现有元素\n\n这可能导致：\n- 性能问题：需要修改更多的 DOM 元素\n- 状态问题：组件状态可能被错误地复用\n\n### 如何正确使用 key\n\n1. **使用唯一标识**：key 应该是每个节点的唯一标识，通常使用 id\n   ```html\n   <!-- 正确 -->\n   <div v-for=\"item in items\" :key=\"item.id\">\n     {{ item.name }}\n   </div>\n   \n   <!-- 错误 -->\n   <div v-for=\"item in items\" :key=\"index\">\n     {{ item.name }}\n   </div>\n   ```\n\n2. **避免使用索引**：不要使用数组索引作为 key，除非列表是静态的\n   - 索引会随着数组排序变化而变化\n   - 可能导致组件状态混乱\n\n3. **结合 transition-group**：在使用 `<transition-group>` 时，必须提供 key\n\n### key 的其他用途\n\n除了在 v-for 中使用，key 还可以：\n\n1. **强制替换元素/组件**：\n   ```html\n   <component :is=\"currentComponent\" :key=\"componentKey\"></component>\n   ```\n   改变 key 会强制 Vue 替换组件而不是复用它\n\n2. **触发过渡效果**：通过改变 key 可以触发元素的进入/离开过渡\n\n### Vue 3 中的变化\n\nVue 3 对 key 的使用更加严格：\n- 在 v-if/v-else-if/v-else 分支中，如果使用了相同的元素标签，需要添加 key\n- 否则 Vue 会尝试复用元素而不是替换它们"
    },
    {
        "id": "twk-question20",
        "topic": "Vue 3 的 Composition API 与 Options API 有什么区别？",
        "isShowAnswer": false,
        "renderType": "markdown",
        "classifyIds": [
            "classify2"
        ],
        "tagList": [
            "Vue相关"
        ],
        "answerContent": "### Options API vs Composition API\n\n**Options API** 是 Vue 2 的主要 API 风格，通过选项对象组织代码：\n```javascript\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  computed: {\n    doubleCount() {\n      return this.count * 2\n    }\n  }\n}\n```\n\n**Composition API** 是 Vue 3 引入的新 API 风格，通过函数组织代码：\n```javascript\nimport { ref, computed } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    \n    function increment() {\n      count.value++\n    }\n    \n    const doubleCount = computed(() => count.value * 2)\n    \n    return {\n      count,\n      increment,\n      doubleCount\n    }\n  }\n}\n```\n\n### 主要区别\n\n| 特性 | Options API | Composition API |\n|------|-------------|-----------------|\n| 代码组织 | 按选项类型组织（data、methods等） | 按逻辑功能组织 |\n| 逻辑复用 | Mixins（有命名冲突问题） | 自定义组合函数 |\n| TypeScript 支持 | 一般 | 更好 |\n| 学习曲线 | 较低，易于初学者理解 | 较高，需要理解响应式原理 |\n| 灵活性 | 较低 | 更高，可以更灵活地组织代码 |\n| 代码复用 | 困难，尤其是跨组件逻辑 | 容易，通过组合函数 |\n| 代码量 | 通常更多 | 通常更少 |\n\n### Composition API 的优势\n\n1. **更好的逻辑组织**：\n   - 相关代码可以组织在一起，而不是分散在不同选项中\n   - 提高了代码的可读性和可维护性\n\n2. **更好的逻辑复用**：\n   - 可以创建自定义组合函数，轻松复用逻辑\n   - 避免了 Mixins 的命名冲突和来源不明确问题\n\n3. **更好的 TypeScript 支持**：\n   - 提供更好的类型推断\n   - 更容易编写类型安全的代码\n\n4. **更灵活的代码组织**：\n   - 可以在多个地方使用 setup 函数\n   - 可以按功能而不是选项类型组织代码\n\n5. **更小的打包体积**：\n   - 更好的 Tree Shaking 支持\n   - 只打包使用的 API\n\n### 使用场景\n\n- **Options API**：适合简单的组件和小型项目\n- **Composition API**：适合复杂的组件和大型项目，需要更好的逻辑组织和复用\n\nVue 3 仍然支持 Options API，开发者可以根据项目需求选择合适的 API 风格。"
    }
]