[
  {
    "id": "vue-interview-1",
    "topic": "Vue 3的生命周期钩子与Vue 2有什么区别？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### Vue 2 vs Vue 3 生命周期钩子\n\nVue 3 的生命周期钩子与 Vue 2 类似，但有一些变化：\n\n1. **重命名的钩子**：\n   - `beforeDestroy` → `beforeUnmount`\n   - `destroyed` → `unmounted`\n\n2. **Composition API 中的新形式**：\n   - 在 Composition API 中，生命周期钩子前面加上了 `on` 前缀\n   - 例如：`beforeMount` 变成 `onBeforeMount`\n\n3. **新增的调试钩子**（Vue 3 特有）：\n   - `onRenderTracked`：跟踪虚拟DOM重新渲染时触发\n   - `onRenderTriggered`：当虚拟DOM重新渲染被触发时调用\n\n4. **使用方式**：\n   - 在 Options API 中使用方式与 Vue 2 相同\n   - 在 Composition API 中需要从 vue 中导入：\n\n```javascript\nimport { onMounted, onUpdated, onUnmounted } from 'vue'\n\nexport default {\n  setup() {\n    onMounted(() => {\n      console.log('组件已挂载')\n    })\n    \n    onUpdated(() => {\n      console.log('组件已更新')\n    })\n    \n    onUnmounted(() => {\n      console.log('组件已卸载')\n    })\n  }\n}\n```"
  },
  {
    "id": "vue-interview-2",
    "topic": "Vue 3 中的 ref 和 reactive 有什么区别？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### ref 和 reactive 的区别\n\nVue 3 提供了两种创建响应式数据的方法：ref 和 reactive。\n\n#### ref\n\n1. **适用类型**：主要用于基本数据类型（string、number、boolean等）\n2. **访问方式**：需要通过 `.value` 属性访问和修改值\n3. **自动解包**：在模板中会自动解包，无需使用 `.value`\n\n```javascript\nimport { ref } from 'vue'\n\nconst count = ref(0)\nconsole.log(count.value) // 0\n\n// 在模板中\n// <template>{{ count }}</template> // 直接显示0，不需要.value\n```\n\n#### reactive\n\n1. **适用类型**：用于对象和数组等引用数据类型\n2. **访问方式**：直接访问属性，无需 `.value`\n3. **限制**：不能直接解构，会丢失响应性\n\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({\n  count: 0,\n  name: 'Vue'\n})\n\nconsole.log(state.count) // 0\n```\n\n#### 使用建议\n\n- 对于基本类型值，使用 `ref`\n- 对于对象或数组，使用 `reactive`\n- 可以使用 `toRefs` 将 reactive 对象转换为 ref 集合以保持解构时的响应性"
  },
  {
    "id": "vue-interview-3",
    "topic": "Vue 3 中的 Teleport 是什么？如何使用？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### Teleport 组件\n\nTeleport 是 Vue 3 引入的一个内置组件，用于将子节点渲染到 DOM 中的指定位置，而不是按照常规的父子关系进行渲染。\n\n#### 使用场景\n\n1. **模态框**：将模态框渲染到 body 元素下，避免受父元素样式影响\n2. **通知和提示**：将通知渲染到页面顶部或底部\n3. **全屏组件**：将组件渲染到全屏容器中\n\n#### 基本用法\n\n```vue\n<template>\n  <div>\n    <h1>当前组件</h1>\n    <Teleport to=\"body\">\n      <div class=\"modal\">\n        <p>这个模态框将被渲染到 body 元素下</p>\n      </div>\n    </Teleport>\n  </div>\n</template>\n```\n\n#### 动态控制\n\n```vue\n<template>\n  <button @click=\"open = true\">打开模态框</button>\n  <Teleport to=\"body\">\n    <div v-if=\"open\" class=\"modal\">\n      <p>模态框内容</p>\n      <button @click=\"open = false\">关闭</button>\n    </div>\n  </Teleport>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst open = ref(false)\n</script>\n```\n\n#### 多个 Teleport\n\n多个 Teleport 可以挂载到同一个目标元素，它们会被追加到目标元素中。"
  },
  {
    "id": "vue-interview-4",
    "topic": "Vue 3 中的 Suspense 组件有什么作用？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### Suspense 组件\n\nSuspense 是 Vue 3 引入的一个内置组件，用于处理异步依赖（如异步组件）的加载状态。\n\n#### 主要作用\n\n1. **处理异步组件加载**：在异步组件加载完成前显示加载状态\n2. **统一加载界面**：提供一致的加载体验\n3. **错误处理**：配合 error boundary 处理加载错误\n\n#### 基本用法\n\n```vue\n<template>\n  <Suspense>\n    <!-- 异步依赖 -->\n    <template #default>\n      <AsyncComponent />\n    </template>\n    \n    <!-- 加载状态 -->\n    <template #fallback>\n      <div>正在加载...</div>\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\n// 异步组件\nconst AsyncComponent = defineAsyncComponent(() =>\n  import('./AsyncComponent.vue')\n)\n</script>\n```\n\n#### 事件处理\n\n```vue\n<template>\n  <Suspense @resolve=\"onResolve\" @fallback=\"onFallback\">\n    <template #default>\n      <AsyncComponent />\n    </template>\n    <template #fallback>\n      <div>加载中...</div>\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nconst onResolve = () => {\n  console.log('异步组件加载完成')\n}\n\nconst onFallback = () => {\n  console.log('显示加载状态')\n}\n</script>\n```"
  },
  {
    "id": "vue-interview-5",
    "topic": "Vue 中的性能优化策略有哪些？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### Vue 性能优化策略\n\n#### 1. 组件优化\n\n- **使用函数式组件**：对于无状态组件，使用函数式组件减少开销\n- **组件懒加载**：使用动态导入实现组件按需加载\n\n```javascript\n// 路由懒加载\nconst Home = () => import('./Home.vue')\n\n// 组件懒加载\nconst AsyncComponent = defineAsyncComponent(() =>\n  import('./ExpensiveComponent.vue')\n)\n```\n\n#### 2. 虚拟列表\n\n对于大量数据的列表渲染，使用虚拟滚动：\n\n```vue\n<template>\n  <RecycleScroller\n    class=\"scroller\"\n    :items=\"list\"\n    :item-size=\"32\"\n    key-field=\"id\"\n    v-slot=\"{ item }\"\n  >\n    <div class=\"user\">{{ item.name }}</div>\n  </RecycleScroller>\n</template>\n```\n\n#### 3. 合理使用 v-show 和 v-if\n\n- **频繁切换**：使用 v-show（仅切换 CSS display）\n- **条件很少满足**：使用 v-if（真正销毁/创建）\n\n#### 4. 正确使用 key\n\n```vue\n<!-- 正确：使用唯一 ID -->\n<li v-for=\"item in list\" :key=\"item.id\">{{ item.name }}</li>\n\n<!-- 错误：使用索引 -->\n<li v-for=\"(item, index) in list\" :key=\"index\">{{ item.name }}</li>\n```\n\n#### 5. 计算属性缓存\n\n```javascript\n// 利用 computed 缓存特性\nconst expensiveValue = computed(() => {\n  return list.value.filter(item => item.active).map(item => item.value * 2)\n})\n```\n\n#### 6. 避免不必要的响应性\n\n```javascript\n// 对于不需要响应性的大对象，使用 markRaw\nimport { markRaw } from 'vue'\n\nconst largeObject = markRaw({\n  // 大量数据\n})\n```\n\n#### 7. 使用 keep-alive 缓存组件\n\n```vue\n<template>\n  <keep-alive>\n    <component :is=\"currentComponent\"></component>\n  </keep-alive>\n</template>\n```\n\n#### 8. 生产环境优化\n\n- 使用生产版本的 Vue\n- 启用 gzip 压缩\n- 使用 CDN 加载第三方库\n- 合理配置 Webpack 代码分割"
  },
  {
    "id": "vue-interview-6",
    "topic": "Vue 3 中的 Fragment 是什么？有什么优势？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### Fragment 组件\n\nFragment 是 Vue 3 中引入的一个重要特性，允许组件拥有多个根节点。\n\n#### Vue 2 的限制\n\n在 Vue 2 中，每个组件模板必须有一个根元素：\n\n```vue\n<!-- Vue 2 中必须有一个根元素 -->\n<template>\n  <div>\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  </div>\n</template>\n```\n\n这会导致额外的 DOM 嵌套层级，有时会影响 CSS 样式布局。\n\n#### Vue 3 的 Fragment\n\nVue 3 中可以有多个根节点：\n\n```vue\n<!-- Vue 3 中可以有多个根节点 -->\n<template>\n  <header>...</header>\n  <main>...</main>\n  <footer>...</footer>\n</template>\n```\n\n#### 优势\n\n1. **减少不必要的 DOM 层级**：避免为了满足单根节点要求而添加额外的包装元素\n2. **更灵活的模板结构**：组件可以更自然地组织其内容\n3. **更好的 CSS 兼容性**：避免因额外的包装元素导致的样式问题\n4. **语义化更好**：不需要为了技术限制而牺牲 HTML 语义\n\n#### 注意事项\n\n使用多个根节点时，v-for 和 v-if 等指令需要使用 template 标签：\n\n```vue\n<template>\n  <template v-for=\"item in list\" :key=\"item.id\">\n    <h1>{{ item.title }}</h1>\n    <p>{{ item.content }}</p>\n  </template>\n</template>\n```"
  },
  {
    "id": "vue-interview-7",
    "topic": "Vue 3 中如何自定义 Hooks？与 Vue 2 的 Mixins 有什么区别？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### 自定义 Hooks\n\nVue 3 的 Composition API 允许我们创建可复用的逻辑代码，称为自定义 Hooks。\n\n#### 创建自定义 Hook\n\n```javascript\n// useCounter.js\nimport { ref, computed } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  \n  const increment = () => {\n    count.value++\n  }\n  \n  const decrement = () => {\n    count.value--\n  }\n  \n  const doubleCount = computed(() => count.value * 2)\n  \n  return {\n    count,\n    increment,\n    decrement,\n    doubleCount\n  }\n}\n```\n\n#### 使用自定义 Hook\n\n```vue\n<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <p>Double Count: {{ doubleCount }}</p>\n    <button @click=\"increment\">+</button>\n    <button @click=\"decrement\">-</button>\n  </div>\n</template>\n\n<script setup>\nimport { useCounter } from './useCounter'\n\nconst { count, increment, decrement, doubleCount } = useCounter(10)\n</script>\n```\n\n#### 与 Mixins 的区别\n\n| 特性 | Mixins | Composition API (自定义 Hooks) |\n|------|--------|-------------------------------|\n| 代码组织 | 按选项类型分散 | 按功能逻辑集中 |\n| 命名冲突 | 可能出现命名冲突 | 明确的变量来源 |\n| 可读性 | 难以理解数据来源 | 清晰的数据流 |\n| TypeScript 支持 | 支持有限 | 优秀的类型推导 |\n| 复用性 | 仅限于选项对象 | 可以返回任意值 |\n\n#### 优势\n\n1. **明确性**：变量来源明确，避免命名冲突\n2. **灵活性**：可以传递参数，返回任意值\n3. **可测试性**：独立的函数更容易测试\n4. **TypeScript 支持**：更好的类型检查和推导"
  },
  {
    "id": "vue-interview-8",
    "topic": "Vue 3 中的响应式更新机制是如何工作的？",
    "notes": "",
    "renderType": "markdown",
    "isShowAnswer": false,
    "classifyIds": [
      "classify2"
    ],
    "tagList": [
      "Vue相关"
    ],
    "answerContent": "### Vue 3 响应式更新机制\n\nVue 3 使用 Proxy 和 effect 的组合来实现响应式更新机制。\n\n#### 核心概念\n\n1. **响应式对象**：使用 Proxy 包装对象，拦截 get/set 操作\n2. **依赖收集**：在 getter 中收集依赖（effect）\n3. **触发更新**：在 setter 中触发依赖更新\n\n#### 工作流程\n\n```javascript\n// 1. 创建响应式对象\nconst state = reactive({ count: 0 })\n\n// 2. 创建 effect\neffect(() => {\n  console.log(state.count) // 访问属性，建立依赖关系\n})\n\n// 3. 修改属性值\nstate.count++ // 触发 setter，执行 effect\n```\n\n#### 详细过程\n\n1. **创建响应式对象**：\n   - 使用 `reactive` 创建 Proxy 对象\n   - 为每个对象创建一个 `targetMap` 映射\n\n2. **依赖收集（track）**：\n   - 访问响应式属性时触发 getter\n   - 将当前 effect 存入 `depsMap` 中\n\n3. **触发更新（trigger）**：\n   - 修改响应式属性时触发 setter\n   - 从 `depsMap` 中取出所有依赖的 effect 并执行\n\n#### 异步更新队列\n\nVue 使用异步更新队列优化性能：\n\n```javascript\n// 同步修改多个属性\nstate.count++\nstate.name = 'Vue'\nstate.active = true\n\n// 实际上只会触发一次更新\nconsole.log('DOM updated')\n```\n\n#### nextTick 机制\n\nVue 使用 nextTick 确保 DOM 更新完成后执行回调：\n\n```javascript\nimport { nextTick } from 'vue'\n\nstate.count++\n\nawait nextTick()\n// DOM 已更新\nconsole.log('DOM updated')\n```\n\n#### 优势\n\n1. **性能优化**：批量更新，避免重复渲染\n2. **精确更新**：只更新依赖变化的部分\n3. **异步处理**：异步更新队列提高渲染性能\n4. **更好的调试**：提供了 renderTracked 和 renderTriggered 钩子用于调试"
  }
]